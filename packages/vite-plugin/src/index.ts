import type { Plugin } from 'vite'
import fs from 'node:fs'
import path from 'node:path'

import { parse } from '@vue/compiler-sfc'
import { parse as babelParse } from '@babel/parser'
import traverse from '@babel/traverse'

const babelTraverse: any = (traverse as any).default ?? traverse
import generate from '@babel/generator'
import * as t from '@babel/types'

export interface DefineExportsBinding {
  exportName: string
  kind: 'identifier' | 'expression'
  identifierName?: string
  expressionCode?: string
}

function isFromLdVue(node: t.ImportDeclaration): boolean {
  return node.source.value === '@ld/vue'
}

function collectDefineExportsLocalNames(ast: t.File): Set<string> {
  const names = new Set<string>()
  babelTraverse(ast, {
    ImportDeclaration(path: any) {
      const node = path.node
      if (!isFromLdVue(node)) return
      for (const spec of node.specifiers) {
        if (t.isImportSpecifier(spec) && t.isIdentifier(spec.imported) && spec.imported.name === 'defineExports') {
          names.add(spec.local.name)
        }
      }
    }
  })
  return names
}

function extractBindingsFromObjectExpression(expr: t.ObjectExpression): DefineExportsBinding[] {
  const out: DefineExportsBinding[] = []

  for (const prop of expr.properties) {
    if (t.isSpreadElement(prop)) continue

    if (t.isObjectProperty(prop)) {
      if (prop.computed) continue

      let exportName: string | null = null
      if (t.isIdentifier(prop.key)) exportName = prop.key.name
      else if (t.isStringLiteral(prop.key)) exportName = prop.key.value

      if (!exportName) continue

      if (prop.shorthand && t.isIdentifier(prop.value)) {
        out.push({ exportName, kind: 'identifier', identifierName: prop.value.name })
        continue
      }

      const code = generate(prop.value, { retainLines: true }).code
      out.push({ exportName, kind: 'expression', expressionCode: code })
      continue
    }

    if (t.isObjectMethod(prop)) {
      if (prop.computed) continue

      let exportName: string | null = null
      if (t.isIdentifier(prop.key)) exportName = prop.key.name
      else if (t.isStringLiteral(prop.key)) exportName = prop.key.value
      if (!exportName) continue

      const code = generate(prop, { retainLines: true }).code
      out.push({ exportName, kind: 'expression', expressionCode: code })
    }
  }

  return out
}

export interface ExtractResult {
  bindings: DefineExportsBinding[]
  removed: boolean
}

function extractDefineExportsFromSetup(scriptSetupCode: string): ExtractResult {
  const ast = babelParse(scriptSetupCode, {
    sourceType: 'module',
    plugins: ['typescript', 'jsx']
  }) as unknown as t.File

  const localNames = collectDefineExportsLocalNames(ast)
  if (localNames.size === 0) return { bindings: [], removed: false }

  const bindings: DefineExportsBinding[] = []
  let removed = false

  babelTraverse(ast, {
    CallExpression(path: any) {
      const callee = path.node.callee
      if (!t.isIdentifier(callee)) return
      if (!localNames.has(callee.name)) return

      const [arg0] = path.node.arguments
      if (!arg0 || !t.isObjectExpression(arg0)) return

      bindings.push(...extractBindingsFromObjectExpression(arg0))

      path.remove()
      removed = true
    }
  })

  return { bindings, removed }
}

function buildRuntimeExportAppendix(bindings: DefineExportsBinding[]): string {
  if (bindings.length === 0) return ''

  const idExports: string[] = []
  const exprExports: string[] = []

  for (const b of bindings) {
    if (b.kind === 'identifier' && b.identifierName) {
      // Only export when exportName === identifierName for PoC.
      // If user wants aliasing, they should use expression form: { foo: bar }
      if (b.exportName === b.identifierName) {
        idExports.push(b.identifierName)
      } else {
        exprExports.push(`export const ${b.exportName} = ${b.identifierName}`)
      }
      continue
    }
    if (b.kind === 'expression' && b.expressionCode) {
      exprExports.push(`export const ${b.exportName} = ${b.expressionCode}`)
    }
  }

  const lines: string[] = []
  lines.push('')
  lines.push('// @ld/vite-plugin: defineExports generated exports')
  if (idExports.length > 0) {
    lines.push(`export { ${idExports.join(', ')} }`)
  }
  lines.push(...exprExports)
  lines.push('')
  return lines.join('\n')
}

function toDtsModuleId(vueId: string): string {
  const base = path.basename(vueId)
  return `*/${base}`
}

function writeVueExportsDts(root: string, exportMap: Map<string, DefineExportsBinding[]>) {
  const outDir = path.join(root, '.ld')
  const outFile = path.join(outDir, 'exports.vue.d.ts')

  fs.mkdirSync(outDir, { recursive: true })

  const lines: string[] = []
  lines.push('// Generated by @ld/vite-plugin (PoC)')
  lines.push('// Provides extra named exports for .vue modules based on defineExports(...) in <script setup>.')
  lines.push('// This file is referenced by ld.d.ts via a triple-slash reference.')
  lines.push('')

  // Ensure default export exists for any .vue module (keeps existing behavior)
  lines.push("declare module '*.vue' {")
  lines.push('  const component: any')
  lines.push('  export default component')
  lines.push('}')
  lines.push('')

  const entries = [...exportMap.entries()].sort((a, b) => a[0].localeCompare(b[0]))

  for (const [vueId, bindings] of entries) {
    const modId = toDtsModuleId(vueId)
    lines.push(`declare module '${modId}' {`)

    for (const b of bindings) {
      // PoC: any types. Later we can infer types via TS AST.
      lines.push(`  export const ${b.exportName}: any`)
    }

    lines.push('}')
    lines.push('')
  }

  fs.writeFileSync(outFile, lines.join('\n'), 'utf8')
}

export function ldExports(): Plugin {
  const exportMap = new Map<string, DefineExportsBinding[]>()
  let rootDir = process.cwd()

  return {
    name: '@ld/vite-plugin-exports',
    enforce: 'pre',

    configResolved(config) {
      rootDir = config.root
    },

    transform(code, id) {
      if (!id.endsWith('.vue')) return null

      const { descriptor } = parse(code, { filename: id })
      const setup = descriptor.scriptSetup
      if (!setup?.content) return null

      const { bindings } = extractDefineExportsFromSetup(setup.content)
      if (bindings.length === 0) return null

      exportMap.set(id, bindings)
      writeVueExportsDts(rootDir, exportMap)

      return null
    },

    // PoC runtime export injection: very naive.
    // TODO: replace with a robust module-level injection based on vue plugin output ids.
    renderChunk(code) {
      // only patch chunks that look like they contain compiled SFC code
      if (!code.includes('__sfc__')) return null

      // match by basename heuristic
      const matchedIds: string[] = []
      for (const vueId of exportMap.keys()) {
        const base = path.basename(vueId)
        if (code.includes(base)) matchedIds.push(vueId)
      }
      if (matchedIds.length === 0) return null

      const merged: DefineExportsBinding[] = []
      for (const mid of matchedIds) merged.push(...(exportMap.get(mid) || []))

      const appendix = buildRuntimeExportAppendix(merged)
      if (!appendix) return null

      return { code: code + appendix, map: null }
    }
  }
}

function ldAotVuePoC(): Plugin {
  return {
    name: '@ld/vite-plugin-aot-vue-poc',
    enforce: 'pre',

    transform(code, id) {
      if (!id.endsWith('.vue')) return null

      const { descriptor } = parse(code, { filename: id })
      const tpl = descriptor.template?.content
      const setup = descriptor.scriptSetup?.content

      if (!tpl || !setup) return null

      // PoC: only match a very small pattern to prove "compile-time direct DOM update"
      // Template: <button @click="inc">{{ count }}</button>
      const tplNormalized = tpl.replace(/\s+/g, ' ').trim()
      if (!/^<button\s+@click="inc"\s*>\s*\{\{\s*count\s*\}\}\s*<\/button>$/.test(tplNormalized)) {
        return null
      }

      // Script setup: must contain "const count = ref(0" and "const inc =" and "count.value++"
      const setupNormalized = setup.replace(/\s+/g, ' ').trim()
      if (!setupNormalized.includes('const count = ref(0') || !setupNormalized.includes('const inc =') || !setupNormalized.includes('count.value++')) {
        return null
      }

      // Replace the whole SFC with a tiny module that exports a mount function.
      // This is intentionally minimal and bypasses runtime reactivity.
      const out = `// @ld/vite-plugin PoC: AOT direct DOM update (no runtime reactivity)\n` +
        `export function mount(el) {\n` +
        `  let _count = 0\n` +
        `  const _btn = document.createElement('button')\n` +
        `  const _text = document.createTextNode('')\n` +
        `  _btn.appendChild(_text)\n` +
        `  function _update(){ _text.nodeValue = String(_count) }\n` +
        `  function inc(){ _count++; _update() }\n` +
        `  _btn.addEventListener('click', inc)\n` +
        `  _update()\n` +
        `  el.appendChild(_btn)\n` +
        `}\n`

      return { code: out, map: null }
    },
  }
}

export default function ldPlugin(): Plugin[] {
  return [ldExports(), ldAotVuePoC()]
}
